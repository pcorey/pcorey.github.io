---
layout: post
title:  "Automate and Build Your Own Tools"
date:   2014-09-03
categories:
---

I was recently tasked with building out hundreds of pages of pdf based forms into online accessible “smart-forms” complete with text-replacement, expanding content and smart inputs (text, datepickers, pre-populated fields, selects, etc…).

At first, I tried to manually build out each of the forms as html/css partials with [AngularJS](https://angularjs.org/) interpolation sections to accomplish my text replacement. I used Angular directives to accomplish any advanced functionality my inputs needed. Building out the forms manually turned out to be a huge undertaking. Simple pages would take ~45 minutes to build, and more extreme forms would take over 3 hours per page. There had to be another way...

After talking with another developer about absolutely positioning the inputs over a screenshot of the form pdf, I realized I had found my solution. Using a static image wasn’t an option since I needed to do things like text-replacement and text color changes. However, using svgs would be the perfect solution. An svg would allow me to use Angular interpolation for text replacement, change text color using <code class="language-*">ng-class</code> and build expanding sections by injecting html in-between the svg objects.

The first thing I needed to do was convert all of the pdf pages into svgs. Each page was standard US Letter size (8.5in x 11in). Thanks to inkscape, I was able to whip up a quick shell script to convert every page file into a corresponding svg:

<pre class="language-bash"><code class="language-bash">#!/usr/bin/zsh

for file in *.pdf; do
   inkscape $file --export-plain-svg=$file.svg
   sed -i 's/width=".*"//g' $file.svg
   sed -i 's/height=".*"/viewBox="0 0 765.75 990.75"/g' $file.svg
done
rename -v 's/pdf\.svg/svg/' *.pdf.svg
</code></pre>

While this isn’t the prettiest script in the world, it saved me a huge chunk of time.

<br/>

After creating all of my svgs, I needed to go through and find where my text replacement and logic-based coloring needed to happen. I probably could have done this with <code class="language-*">sed</code>, but I ended up doing it by hand fairly quickly.


Below is an example of how I modified the svg generated by inkscape, and the corresponding css example:

<pre class="language-markup"><code class="language-markup">&lt;text transform="matrix(1,0,0,-1,195.09,397.14)" id="text278"&gt;
    &lt;tspan
    x="0"
    y="0"
    id="tspan280"
    ng-class="{'invalid': form.name.$invalid}"
    style="font-size:11.00016022px;font-variant:normal;font-weight:normal; ... "&gt;
        Your name is &#123;&#123;data.name&#125;&#125;, and this is an example!
    &lt;/tspan&gt;
&lt;/text&gt;</code></pre>
<pre class="language-css"><code class="language-css">.submitted .invalid {
    fill: #C00000;
}
</code></pre>

The one downside to this technique is that there is no word wrapping support. If your interpolated string is too long, the line will simple run off the document.  I played with using the [foreignObject](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/foreignObject) element to inject html into my svg, but it was not supported in IE.

<br/>

The next step in the process was to manually position each of the inputs. It didn't take long to realize that absolutely positioning each element by hand would still take a considerable amount of time (although it was still faster than the original solution). I needed a tool to help me.

I wanted something that would let me click and drag to outline input boxes. I then needed to specify what type of input it would be (text, datepicker, etc...), and any other parameters about it. I didn't want the tool to get in the way, and I didn't want to design an intense UI, so I opted for a simple [draggable div](https://docs.angularjs.org/guide/directive#creating-a-directive-that-adds-event-listeners). Lastly, I needed a way to export the raw html of the inputs created. All in all, the first iteration of this tool took roughly an hour of tinkering to build.

After using the tool for a few pages, I noticed a few pain points. Originally, I was using the <code class="language-*">w</code>/<code class="language-*">s</code>/<code class="language-*">a</code>/<code class="language-*">d</code> and <code class="language-*">q</code>/<code class="language-*">e</code>/<code class="language-*">r</code>/<code class="language-*">f</code> keys to reposition and resize elements. This was cumbersome and time consuming, so I quickly hacked on mouse control. Holding shift and moving the mouse moved the currently selected elements. Holding alt would resize. Later, I noticed I was frequently creating grids of very similar inputs. Despite how similar they were, I was having to individually create and lay out each element. It took about 30 minutes to add on support for creating and positioning multiple elements simultaneously.

With my tool in its current form, I can build out complex form pages in minutes, as opposed to hours. Honestly, the tool is ugly. The code is some of the worst code I've written in years, but it doesn't need to be good. Aweful, throwaway code saved